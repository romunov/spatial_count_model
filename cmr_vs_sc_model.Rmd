---
title: "Compare credible intervals of SCR models for marked and unmarked individuals"
author: "Roman Luštrik"
date: "Thursday, July 30, 2015"
output: html_document
---

Estimating number of animals can be done in at least two ways. One is using capture-mark-recapture (CMR) framework, where capture histories of individuals are known. A second method is using a method termed "permanent count sites", where on, as you might have guessed it, permanent counting sites, hunters count number of bears during a specific night. Counting is done in special weather conditions and at night. This kind of data could be analyzed using spatial count model (model for unmarked individuals). I will dwell into efford required for one or the other later.

Let's first have a look at how well can population size be estimated using both methods. Based on the code from Spatial capture-recapture by Royle et al. (2014) I will attempt to generate capture histories for individuals and for my next trick, use CMR methods to estimate population size when capture histories are known (Poisson, Binomial) and unknown (for unmarked individuals). In other terms, I will use only the number of bears counted at a specific counting site.

```{r parallel_setup}
library(scrbook)
library(coda)
library(ggplot2)
library(parallel)
library(nimble)

cs <- makeCluster(3)
clusterExport(cl = cs, varlist = c("SCR0pois", "SCR0binom.cl", "scrUN", "e2dist"))
```

```{r joses_nimble_simulation}
jose.binom <- function(S, y, X, K, J, lims, niter) {
  # S = individual centroids
  # y = matrix [nind × ntraps]
  # X = trap locations matrix [nind × 2]
  # K = number of sessions
  # J = number of traps
  # lims = named list of vectors i.e. list(c(xlim = x, ylim = y))
  
  nind <- nrow(y)
  xlim <- lims$xlim
  ylim <- lims$ylim
  
  # xlim <- data$xlim
  # ylim <- data$ylim
  
  area <- (max(xlim) - min(xlim)) * (max(ylim) - min(ylim))
  ## Data augmentation
  M <- 200
  y <- rbind(y,matrix(0,nrow=M-nind,ncol=ncol(y)))
  z <- c(rep(1,nind),rep(0,M-nind))
  ## Init for s
  sst <- cbind(runif(M,xlim[1],xlim[2]),runif(M,ylim[1],ylim[2]))
  for(i in 1:nind){
    sst[i,1] <- mean( X[y[i,]>0,1] )
    sst[i,2] <- mean( X[y[i,]>0,2] )
  }
  
  code <- nimbleCode({
    alpha0 ~ dnorm(0,.1)
    logit(p0) <- alpha0
    alpha1 ~ dnorm(0,.1)
    sigma <- sqrt(1/(2*alpha1))
    psi ~ dunif(0,1)
    for(i in 1:M){
      z[i] ~ dbin(size = 1, psi)
      s[i,1] ~ dunif(xlim[1],xlim[2])
      s[i,2] ~ dunif(ylim[1],ylim[2])
      for(j in 1:J){
        d[i,j] <- pow(pow(s[i,1]-X[j,1],2) + pow(s[i,2]-X[j,2],2),0.5)
        y[i,j] ~ dbin(p[i,j],K)
        p[i,j] <- z[i]*p0*exp(- alpha1*d[i,j]*d[i,j])
      }
    }
    N <- sum(z[1:M])
    D <- N/area
  })
  
  # Jose's nimble version
  constants <- list(M = M, K=K, J=J, area=area)
  data <- list (y=y, X=X, xlim=xlim, ylim=ylim)
  inits <- list (alpha0=0.5, alpha1=1, s=sst, z=z, N=10, D=0.5)
  Rmodel <- nimbleModel(code=code, constants=constants, data=data, inits=inits)
  mcmcspec <- configureMCMC(Rmodel, print=TRUE)
  mcmcspec$addSampler(target = c('N', 'D', 'sigma'), type = 'RW_block',
                      control = list(adaptInterval = 100))
  mcmcspec$addMonitors(c('N', 'D', 'sigma'))
  pumpMCMC <- buildMCMC(mcmcspec)
  Cmodel <- compileNimble(Rmodel)
  CpumpMCMC <- compileNimble(pumpMCMC, project = Rmodel)
  ## execute MCMC algorithm and extract samples
  CpumpMCMC$run(niter)
  
}
```

```{r parallel_simulation}
if (file.exists("progress.txt")) {
  file.remove("progress.txt")
}

sim <- parLapplyLB(cl = cs, X = 1:6, fun = function(x) {
  # sim <- lapply(X = 1, FUN = function(x) {
  #     pb <- txtProgressBar(min = 0, max = 30, width = 30, style = 3)
  #     setTxtProgressBar(pb = pb, value = x)
  
  start.time <- Sys.time()
  
  tr <- seq(15, 85, length = 10)
  
  # create trap grid
  X <- expand.grid(x = tr, y = tr)
  
  # S
  xlim <- c(0, 100)
  ylim <- c(0, 100)
  
  # A = area of S
  A <- (diff(xlim) * diff(ylim))/1e4
  
  mu <- 500
  # we thus treat number of individuals as a Poisson random variable
  N <- rpois(1, mu * A)
  
  s <- cbind(
    runif(N, min = xlim[1], max = xlim[2]),
    runif(N, min = ylim[1], max = ylim[2])
  )
  
  # generate encounter histories under the Poisson model
  sigma <- 5       # detection parameter
  lam0 <- 0.4      # base detection for poisson model
  J <- nrow(X)     # number of traps
  K <- 5           # number of trapping sessions
  p0 <- 0.8        # parameter for binomial model
  
  y <- array(0, c(N, J, K))
  for (j in 1:J) {
    dist <- sqrt((X[j, 1] - s[, 1])^2 + (X[j, 2] - s[, 2])^2)
    lambda <- lam0 * exp(-dist^2/(2 * sigma^2)) # enable for poisson model
    # p <- p0 * exp(-dist^2/(2*sigma^2)) # enable for binomial model
    for (k in 1:K) {
      y[, j, k] <- rpois(N, lambda)
      # y[,j,k] <- rbinom(N, 1, p) 
    }
  }
  
  
  ### CMR model
  # augment data - add 200 of "phantom" individuals
  M <- 700
  # for each trap (J of them), record how many times an individual has been captured
  bin.y <- apply(y, MARGIN = 1:2, FUN = sum)
  bin.y <- bin.y[rowSums(bin.y) != 0, ] # remove non-captured individuals
  augmented.y <- matrix(0, nrow = M, ncol = ncol(y))
  augmented.y[1:nrow(bin.y), ] <- bin.y
  
  # binom.augmented.y <- augmented.y
  # binom.augmented.y[binom.augmented.y > 0] <- 1
  
  # find outer bounds of the trapping grid and add padding
  # Jose J G-H pointed out that padding <- 20 may too much since padding
  # is actually 15+padding. Alternatively I could simulate space-state so
  # that xlim and ylim would include the buffer given sigma.
  padding <- 5
  xl <- min(X$x) - padding
  xu <- max(X$x) + padding
  yl <- min(X$y) - padding
  yu <- max(X$y) + padding
  
  niter <- 5000
  
  # sum the data for each trap across all individuals where result
  # represents number of individuals caught for given trap and session [J × K]
  n <- apply(y, MARGIN = c(2, 3), FUN = sum)
  
  dimnames(n) <- list(paste("trap", 1:J, sep = ""),
                      paste("occasion", 1:K, sep = ""))
  
  # try fitting a model three times
  
  pass.pois <- 3
  while (pass.pois > 0) {
    pois <- tryCatch(mark.pois.N <- SCR0pois(y = augmented.y, X = X, M = M, xl = xl, 
                                             xu = xu, yl = yl, yu = yu, delta = c(1, 0.1, 2), 
                                             niter = niter), 
                     error = function(e) e)
    
    if (any(class(pois) %in% "error")) {
      pass.pois <- pass.pois - 1
    } else {
      break
    }
    
  }
  
  pass.binom <- 10
  while (pass.binom > 0) {
    binom <- tryCatch(SCR0binom.cl(y = augmented.y, X = X, M = M, xl = xl,
                                   xu = xu, yl = yl, yu = yu, K = K, 
                                   delta = c(1, 0.1, 2), niter = niter),
                      error = function(e) e)
    
    if (any(class(binom) %in% "error")) {
      pass.binom <- pass.binom - 1
    } else {
      break
    }
  } 
  
  pass.unmarked <- 3
  while (pass.unmarked > 0) {
    unmarked <- tryCatch(scrUN(n = n, X = X, M = M, niter = niter, xlims = xlim, ylims = ylim,
                               inits = list(lam0 = 0.1, sigma = rnorm(1, mean = 5, sd = 0.1)), updateY = FALSE,
                               tune = c(0.004, 0.09, 0.35)),
                         error = function(e) e)
    
    if (any(class(unmarked) %in% "error")) {
      pass.unmarked <- pass.unmarked - 1
    } else {
      break
    }
  }
  
  
  
  # this logs runs
  timediff <- Sys.time() - start.time
  unit <- attr(timediff, "units")
  log.string <- sprintf("Iteration %d lasted %3.1f %s", x, timediff, unit)
  write(log.string, file = "progress.txt", append = TRUE, sep = "\n")
  
  # write simulations to a file in case things crash
  save(pois, binom, unmarked, x, N, sigma, lam0, J, K, A, file = paste("sim_", x, ".RData", sep = ""))
  
  return(list(pois = pois, binom = binom, unmarked = unmarked, run = x, N = N,
              sigma = sigma, lambda = lam0, J = J, K = K, A = A))
})
```


```{r paranalysis}
# This function will extract N from summary() of MCMC chains
# for each simulation run.
getN <- function(x, mdl, start, stat = "N") {
  # x is a list of simulation runs
  # mdl is character vector either "pois", "binom" or "unmarked"
  # start is the burnin length
  # stat is for which parameter to extract statistic(s)
  
  # get individual models
  ind <- lapply(x, "[[", mdl) # extract pois model diagnostics
  if (mdl == "unmarked") {
    ind <- lapply(ind, "[[", "sims")
  }
  ind <- data.frame(model = mdl, 
                    do.call("rbind", lapply(ind, FUN = function(y) {
                      win <- summary(window(mcmc(y), start = start))
                      win$quantiles["N", ]
                    })),
                    run = 1:length(ind))
  ind
}
```

```{r extract_results}
extractModel <- function(x, start, ...) {
  mcmcbinom <- window(mcmc(x), start = start)
  browser()
  out <- c(summary(mcmcbinom)$quantiles["N", ], ...)
  out
}

getSimResult <- function(x, start) {
  load(x)
  browser()
  sp <- extractModel(x = pois, start = start, mdl = "pois", N = N, A = A, J = J, lam0 = lam0, run = x)
  sb <- extractModel(x = binom, start = start, mdl = "binom", N = N, A = A, J = J, lam0 = lam0, run = x)
  # su <- extractModel(x = unmarked, start = start, mdl = "unmarked", N = N, A = A, J = J, lam0 = lam0, run = x)
  as.data.frame(unname(rbind(sp, sb)))
}
sapply(list.files(pattern = "sim_"), FUN = getSimResult, start = 3000)
```

```{r draw results}
fs <- rbind(spois, sbinom, sunmarked)
fs

ggplot(fs, aes(x = as.factor(run), y = X50.)) +
  theme_bw() +
  geom_pointrange(aes(ymin = X2.5., ymax = X97.5.)) +
  facet_grid(model ~ ., scales = "free_y")
```



