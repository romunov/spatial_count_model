---
title: "Compare credible intervals of SCR models for marked and unmarked individuals"
author: "Roman Luštrik"
date: "Thursday, July 30, 2015"
output: html_document
---

Estimating number of animals can be done in at least two ways. One is using capture-mark-recapture (CMR) framework, where capture histories of individuals are known. A second method is using a method termed "permanent count sites", where on, as you might have guessed it, permanent counting sites, hunters count number of bears during a specific night. Counting is done in special weather conditions and at night. This kind of data could be analyzed using spatial count model (model for unmarked individuals). I will dwell into efford required for one or the other later.

Let's first have a look at how well can population size be estimated using both methods. Based on the code from Spatial capture-recapture by Royle et al. (2014) I will attempt to generate capture histories for individuals and for my next trick, use CMR methods to estimate population size when capture histories are known (Poisson, Binomial) and unknown (for unmarked individuals). In other terms, I will use only the number of bears counted at a specific counting site.

```{r parallel_setup}
library(scrbook)
library(coda)
library(ggplot2)
library(parallel)
library(nimble)

cs <- makeCluster(3)
clusterExport(cl = cs, varlist = c("SCR0pois", "SCR0binom.cl", "scrUN", "e2dist"))
```

```{r joses_nimble_simulation}
jose.binom <- function(S, y, X, K, J, lims, niter) {
  # S = individual centroids
  # y = matrix [nind × ntraps]
  # X = trap locations matrix [nind × 2]
  # K = number of sessions
  # J = number of traps
  # lims = named list of vectors i.e. list(c(xlim = x, ylim = y))
  
  nind <- nrow(y)
  xlim <- lims$xlim
  ylim <- lims$ylim
  
  # xlim <- data$xlim
  # ylim <- data$ylim
  
  area <- (max(xlim) - min(xlim)) * (max(ylim) - min(ylim))
  ## Data augmentation
  M <- 200
  y <- rbind(y,matrix(0,nrow=M-nind,ncol=ncol(y)))
  z <- c(rep(1,nind),rep(0,M-nind))
  ## Init for s
  sst <- cbind(runif(M,xlim[1],xlim[2]),runif(M,ylim[1],ylim[2]))
  for(i in 1:nind){
    sst[i,1] <- mean( X[y[i,]>0,1] )
    sst[i,2] <- mean( X[y[i,]>0,2] )
  }
  
  code <- nimbleCode({
    alpha0 ~ dnorm(0,.1)
    logit(p0) <- alpha0
    alpha1 ~ dnorm(0,.1)
    sigma <- sqrt(1/(2*alpha1))
    psi ~ dunif(0,1)
    for(i in 1:M){
      z[i] ~ dbin(size = 1, psi)
      s[i,1] ~ dunif(xlim[1],xlim[2])
      s[i,2] ~ dunif(ylim[1],ylim[2])
      for(j in 1:J){
        d[i,j] <- pow(pow(s[i,1]-X[j,1],2) + pow(s[i,2]-X[j,2],2),0.5)
        y[i,j] ~ dbin(p[i,j],K)
        p[i,j] <- z[i]*p0*exp(- alpha1*d[i,j]*d[i,j])
      }
    }
    N <- sum(z[1:M])
    D <- N/area
  })
  
  # Jose's nimble version
  constants <- list(M = M, K=K, J=J, area=area)
  data <- list (y=y, X=X, xlim=xlim, ylim=ylim)
  inits <- list (alpha0=0.5, alpha1=1, s=sst, z=z, N=10, D=0.5)
  Rmodel <- nimbleModel(code=code, constants=constants, data=data, inits=inits)
  mcmcspec <- configureMCMC(Rmodel, print=TRUE)
  mcmcspec$addSampler(target = c('N', 'D', 'sigma'), type = 'RW_block',
                      control = list(adaptInterval = 100))
  mcmcspec$addMonitors(c('N', 'D', 'sigma'))
  pumpMCMC <- buildMCMC(mcmcspec)
  Cmodel <- compileNimble(Rmodel)
  CpumpMCMC <- compileNimble(pumpMCMC, project = Rmodel)
  ## execute MCMC algorithm and extract samples
  CpumpMCMC$run(niter)
  
}
```

```{r parafunction}
paraFunction <- function(x, pass = 100, data.model = c("poisson", "binomial"),
                         niter) {
  # x is a phantom parameter (not used)
  # pass is number of times a model is run because sometimes initial parameters produce error(s)
  # data.model indicates which model is used to generate data
  
  # sim <- lapply(X = 1, FUN = function(x) {
  #     pb <- txtProgressBar(min = 0, max = 30, width = 30, style = 3)
  #     setTxtProgressBar(pb = pb, value = x)
  
  start.time <- Sys.time()
  
  tr <- seq(15, 85, length = 10)
  
  # create trap grid
  X <- expand.grid(x = tr, y = tr)
  
  # S
  xlim <- c(0, 100)
  ylim <- c(0, 100)
  
  # A = area of S
  A <- (diff(xlim) * diff(ylim))/1e4
  
  mu <- 500
  # we thus treat number of individuals as a Poisson random variable
  N <- rpois(1, mu * A)
  
  s <- cbind(
    runif(N, min = xlim[1], max = xlim[2]),
    runif(N, min = ylim[1], max = ylim[2])
  )
  
  # generate encounter histories under the Poisson model
  sigma <- 5       # detection parameter
  lam0 <- 0.4      # base detection for poisson model
  J <- nrow(X)     # number of traps
  K <- 5           # number of trapping sessions
  p0 <- 0.8        # parameter for binomial model
  
  y <- array(0, c(N, J, K))
  
  if (data.model == "poisson") {
    for (j in 1:J) {
      dist <- sqrt((X[j, 1] - s[, 1])^2 + (X[j, 2] - s[, 2])^2)
      lambda <- lam0 * exp(-dist^2/(2 * sigma^2))
      for (k in 1:K) {
        y[, j, k] <- rpois(N, lambda)
      }
    }
  }
  
  if (data.model == "binomial") {
    
    for (j in 1:J) {
      dist <- sqrt((X[j, 1] - s[, 1])^2 + (X[j, 2] - s[, 2])^2)
      p <- p0 * exp(-dist^2/(2*sigma^2))
      for (k in 1:K) {
        y[, j, k] <- rbinom(N, 1, p) 
      }
    }
  }
  
  
  ### CMR model
  # augment data - add 200 of "phantom" individuals
  M <- 700
  # for each trap (J of them), record how many times an individual has been captured
  bin.y <- apply(y, MARGIN = 1:2, FUN = sum)
  bin.y <- bin.y[rowSums(bin.y) != 0, ] # remove non-captured individuals
  augmented.y <- matrix(0, nrow = M, ncol = ncol(y))
  augmented.y[1:nrow(bin.y), ] <- bin.y
  
  # binom.augmented.y <- augmented.y
  # binom.augmented.y[binom.augmented.y > 0] <- 1
  
  # find outer bounds of the trapping grid and add padding
  # Jose J G-H pointed out that padding <- 20 may too much since padding
  # is actually 15+padding. Alternatively I could simulate space-state so
  # that xlim and ylim would include the buffer given sigma.
  padding <- 5
  xl <- min(X$x) - padding
  xu <- max(X$x) + padding
  yl <- min(X$y) - padding
  yu <- max(X$y) + padding
  
  # sum the data for each trap across all individuals where result
  # represents number of individuals caught for given trap and session [J × K]
  n <- apply(y, MARGIN = c(2, 3), FUN = sum)
  
  dimnames(n) <- list(paste("trap", 1:J, sep = ""),
                      paste("occasion", 1:K, sep = ""))
  
  # try fitting a model "pass" times
  pass.pois <- pass
  while (pass.pois > 0) {
    pois <- tryCatch(SCR0pois(y = augmented.y, X = X, M = M, xl = xl, 
                              xu = xu, yl = yl, yu = yu, delta = c(1, 0.1, 2), 
                              niter = niter), 
                     error = function(e) e)
    
    if (any(class(pois) %in% "error")) {
      pass.pois <- pass.pois - 1
    } else {
      break
    }
  }
  
  pass.binom <- pass
  while (pass.binom > 0) {
    binom <- tryCatch(SCR0binom.cl(y = augmented.y, X = X, M = M, xl = xl,
                                   xu = xu, yl = yl, yu = yu, K = K, 
                                   delta = c(1, 0.1, 2), niter = niter),
                      error = function(e) e)
    
    if (any(class(binom) %in% "error")) {
      pass.binom <- pass.binom - 1
    } else {
      break
    }
  } 
  
  pass.unmarked <- pass
  while (pass.unmarked > 0) {
    unmarked <- tryCatch(scrUN(n = n, X = X, M = M, niter = niter, xlims = xlim, ylims = ylim,
                               inits = list(lam0 = 0.1, sigma = rnorm(1, mean = 5, sd = 0.1)), updateY = FALSE,
                               tune = c(0.004, 0.09, 0.35)),
                         error = function(e) e)
    
    if (any(class(unmarked) %in% "error")) {
      pass.unmarked <- pass.unmarked - 1
    } else {
      break
    }
  }
  
  # this logs runs
  timediff <- Sys.time() - start.time
  unit <- attr(timediff, "units")
  log.string <- sprintf("Iteration %d lasted %3.1f %s", x, timediff, unit)
  write(log.string, file = "progress.txt", append = TRUE, sep = "\n")
  
  # write simulations to a file in case things crash
  save(pois, binom, unmarked, x, N, sigma, lam0, J, K, A, data.model, file = paste("sim_", x, "_", data.model, "_", ".RData", sep = ""))
  
  return(list(pois = pois, binom = binom, unmarked = unmarked, run = x, N = N,
              sigma = sigma, lambda = lam0, J = J, K = K, A = A, data.model = data.model))
}
```

```{r parallel_simulation}
if (file.exists("progress.txt")) {
  file.remove("progress.txt")
}

sim.poisson <- parLapplyLB(cl = cs, X = 1:12, fun = paraFunction, data.model = "poisson", niter = 5000)
sim.binomial <- parLapplyLB(cl = cs, X = 1:12, fun = paraFunction, data.model = "binomial", niter = 5000)
```

```{r}
# Each simulation run is stored in a .RData file and contains estimates of a dataset
# using binomial, Poisson and unmarked model. Each .RData file is in turn scraped for
# results and stored as `res`.
res <- sapply(X = list.files(pattern = "sim_"), FUN = function(x) {
  
  load(x)
  
  # Try to find statistics for the model. If it fails it produces empty result.
  b <- tryCatch(expr = summary(mcmc(binom))$quantiles["N", ], 
                error = function(e) structure(c(NA, NA, NA, NA, NA), .Names = c("2.5%", "25%", 
                                                                                "50%", "75%", "97.5%")))
  p <- tryCatch(expr = summary(mcmc(pois))$quantiles["N", ],
                error = function(e) structure(c(NA, NA, NA, NA, NA), .Names = c("2.5%", "25%", 
                                                                                "50%", "75%", "97.5%")))
  u <- tryCatch(expr = summary(mcmc(unmarked[[1]]))$quantiles["N", ],
                error = function(e) structure(c(NA, NA, NA, NA, NA), .Names = c("2.5%", "25%", 
                                                                                "50%", "75%", "97.5%")))
  # Combine all parameters into one single data.frame.
  res <- data.frame(rbind(binom = b, poisson = p, unmarked = u, data.model,
                    A, J, K, lam0, N, sigma, run = x, model = c("binom", "poisson", "unmarked")))
  res
}, simplify = FALSE)

res <- do.call("rbind", res) # merge list into a data.frame

ggplot(res, aes(x = as.factor(run), y = X50., color = data.model)) +
  theme_bw() +
  xlab("Run") +
  ylab("Estimated number of individuals") +
  geom_pointrange(aes(ymin = X2.5., ymax = X97.5.)) +
  geom_point(aes(y = N), color = "red") +
  facet_grid(. ~ model)
```


